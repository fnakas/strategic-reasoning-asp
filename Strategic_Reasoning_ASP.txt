player(0;1).index(1..3).square(cell(X,Y)) :- index(X), index(Y).time(1..9).direction(left;right).part_of(cell(X,Y), row(X)) :- index(X), index(Y).part_of(cell(X,Y), col(Y)) :- index(X), index(Y).part_of(cell(X,X), diag(left)) :- index(X).part_of(cell(X,4-X), diag(right)) :- index(X).part_of(diag(D), diag_space) :- direction(D).part_of(cell(X,Y), edge_space) :- square(cell(X,Y)), not part_of(cell(X,Y), diag_space).part_of(cell(X,Y), board) :- square(cell(X,Y)).part_of(X,Y) :- part_of(X,Z), part_of(Z,Y).board_entity(Y) :- part_of(X,Y), square(X).line(row(X)) :- index(X).line(col(Y)) :- index(Y).line(diag(D)) :- direction(D).holds(marked(P,Y,N),T) :- {holds(marked(P,X),T) : square(X), part_of(X,Y)} == N, N = 0..3, player(P), time(T), board_entity(Y).holds(threatens(P,L,N),T) :- player(P), line(L), holds(marked(P,L,N),T), holds(marked(1-P,L,M),T), M == 0.holds(gets_three(P,L),T) :- player(P), line(L), holds(marked(P,L,3),T).wins(P,T) :- holds(gets_three(P,L),T).open_board(T) :- square(C), time(T), not holds(marked(0,C),T), not holds(marked(1,C),T).terminal(T) :- wins(P,T).terminal(T) :- time(T), not open_board(T).tie(T) :- not wins(0,T), not wins(1,T), terminal(T).action(a(P,C)) :- player(P), square(C).holds (turn (0) ,1).holds (turn (P),T+1) :- holds (turn (1-P),T), time(T).legal (a(P,C),T) :- holds(turn(P),T), action(a(P,C)), not holds(marked(P,C),T), not holds(marked(1-P,C),T), time(T), not terminal(T).holds (marked(P,C), T+1) :- holds(marked(P,C),T), player(P), square(C), time(T), not terminal(T).holds (marked(P,C), T+1) :- action(a(P,C)), does(a(P,C),T), time(T).1 { does (A,T) : action (A) } 1 :- time(T), not terminal(T).:- does(A,T), not legal (A,T).:- non_strategic(T).non_strategic(T) :- does(A,T), not strat (A,T).defend_threat(a(P,C),T) :- action(a(P,C)), time(T), holds(threatens(1-P,L,2),T), part_of(C,L).defeat(a(P,C),T) :- action(a(P,C)), time(T),holds(threatens(P,L,2),T), part_of(C,L).fork(a(P,C),T) :- action(a(P,C)), time(T),holds(threatens(P,L1,1),T), holds(threatens(P,L2,1),T), L1 != L2, part_of(C, L1), part_of(C,L2).mark_diag_space(a(P,C),T) :- action(a(P,C)), time(T),part_of(C, diag_space).mark_edge_space(a(P,C),T) :- action(a(P,C)), time(T),part_of(C, edge_space).threaten_non_center(a(P,C),T) :- action(a(P,C)), time(T),holds(threatens(P,L,1),T), part_of(C,L), part_of(C1, L), not holds(marked(P, C1), T), C1 != C, C1 != cell(2,2).mark_any(a(P,C),T) :- action(a(P,C)), time(T), square(C).capture_center(a(P,C),T) :- action(a(P,C)), time(T), C == cell(2,2).exists_defeat(P,T) :- defeat(a(P,C),T).exists_defend_threat(P,T) :- defend_threat(a(P,C),T).exists_fork(P,T) :- fork(a(P,C),T).exists_threaten_non_center(P,T) :- threaten_non_center(a(P,C),T).exists_mark_diag_space(P,T) :- mark_diag_space(a(P,C),T).exists_capture_center(P,T) :- capture_center(a(P,C),T).strat_good_for_X(a(P,C),T) :- defeat(a(P,C),T).strat_good_for_X(a(P,C),T) :- defend_threat(a(P,C),T), not exists_defeat(P,T).strat_good_for_X(a(P,C),T) :- fork(a(P,C),T), not exists_defeat(P,T), not exists_defend_threat(P,T).strat_good_for_X(a(P,C),T) :- mark_diag_space(a(P,C),T), threaten_non_center(a(P,C),T), not exists_defeat(P,T), not exists_defend_threat(P,T), not exists_fork(P,T).strat_good_for_X(a(P,C),T) :- mark_diag_space(a(P,C),T), not exists_threaten_non_center(P,T), not exists_defeat(P,T), not exists_defend_threat(P,T), not exists_fork(P,T).strat_good_for_X(a(P,C),T) :- mark_any(a(P,C),T), not mark_diag_space(a(P,C),T), not exists_threaten_non_center(P,T), not exists_defeat(P,T), not exists_defend_threat(P,T), not exists_fork(P,T).strat_good_for_O(a(P,C),T) :- defeat(a(P,C),T).strat_good_for_O(a(P,C),T) :- defend_threat(a(P,C),T), not exists_defeat(P,T).strat_good_for_O(a(P,C),T) :- fork(a(P,C),T), not exists_defeat(P,T), not exists_defend_threat(P,T).strat_good_for_O(a(P,C),T) :- mark_diag_space(a(P,C),T), capture_center(a(P,C),T), not exists_defeat(P,T), not exists_defend_threat(P,T), not exists_fork(P,T).strat_good_for_O(a(P,C),T) :- mark_diag_space(a(P,C),T), not exists_capture_center(P,T), not exists_defeat(P,T), not exists_defend_threat(P,T), not exists_fork(P,T).strat_good_for_O(a(P,C),T) :- mark_any(a(P,C),T), not exists_capture_center(P,T), not exists_threaten_non_center(P,T), not exists_defeat(P,T), not exists_defend_threat(P,T), not exists_fork(P,T).strat_any(a(P,C),T) :- mark_any(a(P,C),T).strat_edge_mistake_O(a(1,C),2) :- mark_edge_space(a(1,C),2).strat_edge_mistake_O(a(1,C),T) :- time(T), T!= 2, square(C).%decide the strategy for each player using one of the strategies above%playerX has index 0 and playerO has index 1strat(a(1,C),T) :- strat_good_for_O(a(1,C),T).strat(a(0,C),T) :- strat_good_for_X(a(0,C),T).winsO :- wins(1,T), terminal(T).winsX :- wins(0,T), terminal(T).tie :- tie(T).%decide on a constrain given what you want to prove. For example, %if there are no answer sets for %:- not tie, we infer that the game will always be a tie.%:- winsX, we infer that player X always wins.%:- not winsX, we infer that player O never loses.%:- winsO, we infer that player O always wins.%:- not winsO, we infer that player X never loses.:- not tie.#show does/2.#show terminal/1.#show wins/2.#show tie/1.